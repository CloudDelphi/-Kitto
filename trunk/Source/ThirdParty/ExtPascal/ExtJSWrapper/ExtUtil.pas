unit ExtUtil;

// Generated by ExtToPascal v.0.9.8, at 3/5/2010 11:59:34
// from "C:\Trabalho\ext\docs\output" detected as ExtJS v.3

interface

uses
  Classes, StrUtils, ExtPascal, ExtPascalUtils;

type
(*
  TExtUtilObservable = class;
  TExtUtilJSONSingleton = class;
  TExtUtilTextMetricsSingleton = class;
  TExtUtilFormatSingleton = class;
  TExtUtilCSSSingleton = class;
  TExtUtilCookiesSingleton = class;
  TExtUtilDelayedTask = class;
  TExtUtilMixedCollection = class;
*)
  TExtUtilObservable = class(TExtFunction)
  private
    FListeners: TExtObject;
    procedure SetFListeners(Value: TExtObject);
  protected
    procedure InitDefaults; override;
  public
    class function JSClassName: string; override;
    function ObservableCapture(O: TExtUtilObservable; Fn: TExtFunction;
      Scope: TExtObject = nil): TExtFunction;
    function ObservableObserveClass(C: TExtFunction; Listeners: TExtObject): TExtFunction;
    function ObservableReleaseCapture(O: TExtUtilObservable): TExtFunction;
    function AddEvents(O: TExtObject; Optional: string): TExtFunction; overload;
    function AddEvents(O: string; Optional: string): TExtFunction; overload;
    function AddListener(EventName: string; Handler: TExtFunction;
      Scope: TExtObject = nil; Options: TExtObject = nil): TExtFunction;
    function EnableBubble(Events: string): TExtFunction; overload;
    function EnableBubble(Events: TExtObjectList): TExtFunction; overload;
    function FireEvent(EventName: string; Args: TExtObjectList): TExtFunction;
    function HasListener(EventName: string): TExtFunction;
    function &On(const AEventName: string; const AHandler: TExtFunction;
      const AScope: TExtObject = nil; const AOptions: TExtObject = nil): TExtFunction;
    function PurgeListeners: TExtFunction;
    function RelayEvents(O: TExtObject; Events: TExtObjectList): TExtFunction;
    function RemoveListener(EventName: string; Handler: TExtFunction;
      Scope: TExtObject = nil): TExtFunction;
    function ResumeEvents: TExtFunction;
    function SuspendEvents(QueueSuspended: Boolean): TExtFunction;
    function Un(EventName: string; Handler: TExtFunction; Scope: TExtObject = nil)
      : TExtFunction;
    property Listeners: TExtObject read FListeners write SetFListeners;
  end;

  TExtUtilJSONSingleton = class(TExtFunction)
  public
    class function JSClassName: string; override;
    function Decode(Json: string): TExtFunction;
    function Encode(O: string): TExtFunction;
    function EncodeDate(D: TDateTime): TExtFunction;
  end;

  TExtUtilTextMetricsSingleton = class(TExtFunction)
  public
    class function JSClassName: string; override;
    function Bind(El: string): TExtFunction; overload;
    function Bind(El: THTMLElement): TExtFunction; overload;
    function CreateInstance(El: string; FixedWidth: Integer = 0): TExtFunction; overload;
    function CreateInstance(El: THTMLElement; FixedWidth: Integer = 0)
      : TExtFunction; overload;
    function GetHeight(const AText: string): TExtFunction;
    function GetSize(Text: string): TExtFunction;
    function GetWidth(const AText: string): TExtFunction;
    function Measure(El: string; Text: string; FixedWidth: Integer = 0)
      : TExtFunction; overload;
    function Measure(El: THTMLElement; Text: string; FixedWidth: Integer = 0)
      : TExtFunction; overload;
    function SetFixedWidth(Width: Integer): TExtFunction;
  end;

  TExtUtilFormatSingleton = class(TExtFunction)
  public
    class function JSClassName: string; override;
    function Capitalize(Value: string): TExtFunction;
    function Date(Value: string; Format: string = ''): TExtFunction; overload;
    function Date(Value: TDateTime; Format: string = ''): TExtFunction; overload;
    function DateRenderer(Format: string): TExtFunction;
    function DefaultValue(Value: string; DefaultValue: string): TExtFunction;
    function Ellipsis(Value: string; Length: Integer; Word: Boolean): TExtFunction;
    function FileSize(Size: Integer): TExtFunction; overload;
    function FileSize(Size: string): TExtFunction; overload;
    function HtmlDecode(Value: string): TExtFunction;
    function HtmlEncode(Value: string): TExtFunction;
    function Lowercase(Value: string): TExtFunction;
    function Math: TExtFunction;
    function Nl2br(The: string): TExtFunction;
    function Number(V: Integer; Format: string): TExtFunction;
    function NumberRenderer(Format: string): TExtFunction;
    function Plural(Value: Integer; Singular: string; Plural: string = ''): TExtFunction;
    function Round(Value: Integer; Precision: Integer): TExtFunction; overload;
    function Round(Value: string; Precision: Integer): TExtFunction; overload;
    function StripScripts(Value: string): TExtFunction;
    function StripTags(Value: string): TExtFunction;
    function Substr(Value: string; Start: Integer; Length: Integer): TExtFunction;
    function Trim(Value: string): TExtFunction;
    function Undef(Value: string): TExtFunction;
    function Uppercase(Value: string): TExtFunction;
    function UsMoney(Value: Integer): TExtFunction; overload;
    function UsMoney(Value: string): TExtFunction; overload;
  end;

  TExtUtilCSSSingleton = class(TExtFunction)
  public
    class function JSClassName: string; override;
    function CreateStyleSheet(CssText: string; Id: string): TExtFunction;
    function GetRule(Selector: string; RefreshCache: Boolean): TExtFunction; overload;
    function GetRule(Selector: TExtObjectList; RefreshCache: Boolean)
      : TExtFunction; overload;
    function GetRules(RefreshCache: Boolean): TExtFunction;
    function RefreshCache: TExtFunction;
    function RemoveStyleSheet(Id: string): TExtFunction;
    function SwapStyleSheet(Id: string; Url: string): TExtFunction;
    function UpdateRule(Selector: string; PropertyJS: string; Value: string)
      : TExtFunction; overload;
    function UpdateRule(Selector: TExtObjectList; PropertyJS: string; Value: string)
      : TExtFunction; overload;
  end;

  TExtUtilCookiesSingleton = class(TExtFunction)
  public
    class function JSClassName: string; override;
    function Clear(Name: string): TExtFunction;
    function Get(Name: string): TExtFunction;
    function SetJS(Name: string; Value: string; Expires: TExtObject = nil;
      Path: string = ''; Domain: string = ''; Secure: Boolean = false): TExtFunction;
  end;

  TExtUtilDelayedTask = class(TExtFunction)
  public
    class function JSClassName: string; override;
    constructor Create(AOwner: TComponent; Fn: TExtFunction = nil;
      Scope: TExtObject = nil; Args: TExtObjectList = nil); reintroduce;
    function Cancel: TExtFunction;
    function Delay(Delay: Integer; NewFn: TExtFunction = nil; NewScope: TExtObject = nil;
      NewArgs: TExtObjectList = nil): TExtFunction;
  end;

  // Procedural types for events TExtUtilMixedCollection
  TExtUtilMixedCollectionOnAdd = procedure(Index: Integer; O: TExtObject; Key: string)
    of object;
  TExtUtilMixedCollectionOnClear = procedure of object;
  TExtUtilMixedCollectionOnRemove = procedure(O: TExtObject; Key: string = '') of object;
  TExtUtilMixedCollectionOnReplace = procedure(Key: string; Old: TExtObject;
    New: TExtObject) of object;

  TExtUtilMixedCollection = class(TExtUtilObservable)
  private
    FAllowFunctions: Boolean;
    FOnAdd: TExtUtilMixedCollectionOnAdd;
    FOnClear: TExtUtilMixedCollectionOnClear;
    FOnRemove: TExtUtilMixedCollectionOnRemove;
    FOnReplace: TExtUtilMixedCollectionOnReplace;
    procedure SetFAllowFunctions(Value: Boolean);
    procedure SetFOnAdd(Value: TExtUtilMixedCollectionOnAdd);
    procedure SetFOnClear(Value: TExtUtilMixedCollectionOnClear);
    procedure SetFOnRemove(Value: TExtUtilMixedCollectionOnRemove);
    procedure SetFOnReplace(Value: TExtUtilMixedCollectionOnReplace);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    class function JSClassName: string; override;
    constructor Create(AOwner: TComponent; AllowFunctions: Boolean; KeyFn: TExtFunction);
      reintroduce;
    function Add(Key: string; O: TExtObject): TExtFunction;
    function AddAll(Objs: TExtObject): TExtFunction; overload;
    function AddAll(Objs: TExtObjectList): TExtFunction; overload;
    function Clear: TExtFunction;
    function Clone: TExtFunction;
    function Contains(O: TExtObject): TExtFunction;
    function ContainsKey(Key: string): TExtFunction;
    function Each(Fn: TExtFunction; Scope: TExtObject = nil): TExtFunction;
    function EachKey(Fn: TExtFunction; Scope: TExtObject = nil): TExtFunction;
    function Filter(PropertyJS: string; Value: string; AnyMatch: Boolean = false;
      CaseSensitive: Boolean = false): TExtFunction; overload;
    function Filter(PropertyJS: string; Value: TRegExp; AnyMatch: Boolean = false;
      CaseSensitive: Boolean = false): TExtFunction; overload;
    function FilterBy(Fn: TExtFunction; Scope: TExtObject = nil): TExtFunction;
    function Find(Fn: TExtFunction; Scope: TExtObject = nil): TExtFunction;
    function FindIndex(PropertyJS: string; Value: string; Start: Integer = 0;
      AnyMatch: Boolean = false; CaseSensitive: Boolean = false): TExtFunction; overload;
    function FindIndex(PropertyJS: string; Value: TRegExp; Start: Integer = 0;
      AnyMatch: Boolean = false; CaseSensitive: Boolean = false): TExtFunction; overload;
    function FindIndexBy(Fn: TExtFunction; Scope: TExtObject = nil; Start: Integer = 0)
      : TExtFunction;
    function First: TExtFunction;
    function Get(Key: string): TExtFunction; overload;
    function Get(Key: Integer): TExtFunction; overload;
    function GetCount: TExtFunction;
    function GetKey(Item: TExtObject): TExtFunction;
    function GetRange(StartIndex: Integer = 0; EndIndex: Integer = 0): TExtFunction;
    function IndexOf(O: TExtObject): TExtFunction;
    function IndexOfKey(Key: string): TExtFunction;
    function Insert(Index: Integer; Key: string; O: TExtObject = nil): TExtFunction;
    function Item(Key: string): TExtFunction; overload;
    function Item(Key: Integer): TExtFunction; overload;
    function ItemAt(Index: Integer): TExtFunction;
    function Key(Key: string): TExtFunction; overload;
    function Key(Key: Integer): TExtFunction; overload;
    function KeySort(Direction: string = ''; Fn: TExtFunction = nil): TExtFunction;
    function Last: TExtFunction;
    function Remove(O: TExtObject): TExtFunction;
    function RemoveAt(Index: Integer): TExtFunction;
    function RemoveKey(Key: string): TExtFunction;
    function Reorder(Mapping: TExtObject): TExtFunction;
    function Replace(Key: string; O: TExtObject): TExtFunction;
    function Sort(Direction: string = ''; Fn: TExtFunction = nil): TExtFunction;
    property AllowFunctions: Boolean read FAllowFunctions write SetFAllowFunctions;
    property OnAdd: TExtUtilMixedCollectionOnAdd read FOnAdd write SetFOnAdd;
    property OnClear: TExtUtilMixedCollectionOnClear read FOnClear write SetFOnClear;
    property OnRemove: TExtUtilMixedCollectionOnRemove read FOnRemove write SetFOnRemove;
    property OnReplace: TExtUtilMixedCollectionOnReplace read FOnReplace
      write SetFOnReplace;
  end;

function ExtUtilJSON: TExtUtilJSONSingleton;
function ExtUtilTextMetrics: TExtUtilTextMetricsSingleton;
function ExtUtilFormat: TExtUtilFormatSingleton;
function ExtUtilCSS: TExtUtilCSSSingleton;
function ExtUtilCookies: TExtUtilCookiesSingleton;

implementation

function ExtUtilJSON: TExtUtilJSONSingleton;
begin
  if (Session <> nil) then
    Result := Session.GetSingleton<TExtUtilJSONSingleton>(TExtUtilJSONSingleton.JSClassName)
  else
    Result := nil;
end;

function ExtUtilTextMetrics: TExtUtilTextMetricsSingleton;
begin
  if (Session <> nil) then
    // 'TextMetrics' is the name of the custom instance we create and bind
    // to the <body> element.
    Result := Session.GetSingleton<TExtUtilTextMetricsSingleton>('TextMetrics')
  else
    Result := nil;
end;

function ExtUtilFormat: TExtUtilFormatSingleton;
begin
  if (Session <> nil) then
    Result := Session.GetSingleton<TExtUtilFormatSingleton>(TExtUtilFormatSingleton.JSClassName)
  else
    Result := nil;
end;

function ExtUtilCSS: TExtUtilCSSSingleton;
begin
  if (Session <> nil) then
    Result := Session.GetSingleton<TExtUtilCSSSingleton>(TExtUtilCSSSingleton.JSClassName)
  else
    Result := nil;
end;

function ExtUtilCookies: TExtUtilCookiesSingleton;
begin
  if (Session <> nil) then
    Result := Session.GetSingleton<TExtUtilCookiesSingleton>(TExtUtilCookiesSingleton.JSClassName)
  else
    Result := nil;
end;

procedure TExtUtilObservable.SetFListeners(Value: TExtObject);
begin
  FListeners.Free;
  FListeners := Value;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

class function TExtUtilObservable.JSClassName: string;
begin
  Result := 'Ext.util.Observable';
end;

procedure TExtUtilObservable.InitDefaults;
begin
  inherited;
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

function TExtUtilObservable.ObservableCapture(O: TExtUtilObservable; Fn: TExtFunction;
  Scope: TExtObject = nil): TExtFunction;
begin
  JSCode(JSName + '.Observable.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) +
    ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ObservableObserveClass(C: TExtFunction; Listeners: TExtObject)
  : TExtFunction;
begin
  JSCode(JSName + '.Observable.observeClass(' + VarToJSON([C, true, Listeners, false]) +
    ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ObservableReleaseCapture(O: TExtUtilObservable): TExtFunction;
begin
  JSCode(JSName + '.Observable.releaseCapture(' + VarToJSON([O, false]) + ');',
    'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddEvents(O: TExtObject; Optional: string): TExtFunction;
begin
  JSCode(JSName + '.addEvents(' + VarToJSON([O, false, Optional]) + ');',
    'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddEvents(O: string; Optional: string): TExtFunction;
begin
  JSCode(JSName + '.addEvents(' + VarToJSON([O, Optional]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddListener(EventName: string; Handler: TExtFunction;
  Scope: TExtObject = nil; Options: TExtObject = nil): TExtFunction;
begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Handler, true, Scope, false,
    Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.EnableBubble(Events: string): TExtFunction;
begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([Events]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.EnableBubble(Events: TExtObjectList): TExtFunction;
begin
  JSCode(JSName + '.enableBubble(' + VarToJSON(Events) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.FireEvent(EventName: string; Args: TExtObjectList)
  : TExtFunction;
begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');',
    'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.HasListener(EventName: string): TExtFunction;
begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.&On(const AEventName: string; const AHandler: TExtFunction;
  const AScope: TExtObject; const AOptions: TExtObject): TExtFunction;
begin
  ExtSession.ResponseItems.CallMethod(Self, 'on', [AEventName, AHandler, True, AScope, False, AOptions, False]);
  Result := Self;
end;

function TExtUtilObservable.PurgeListeners: TExtFunction;
begin
  JSCode(JSName + '.purgeListeners();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RelayEvents(O: TExtObject; Events: TExtObjectList)
  : TExtFunction;
begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([O, false]) + ',' + VarToJSON(Events) +
    ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveListener(EventName: string; Handler: TExtFunction;
  Scope: TExtObject = nil): TExtFunction;
begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Handler, true, Scope, false])
    + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ResumeEvents: TExtFunction;
begin
  JSCode(JSName + '.resumeEvents();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.SuspendEvents(QueueSuspended: Boolean): TExtFunction;
begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');',
    'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.Un(EventName: string; Handler: TExtFunction;
  Scope: TExtObject = nil): TExtFunction;
begin
  JSCode(JSName + '.un(' + VarToJSON([EventName, Handler, true, Scope, false]) + ');',
    'TExtUtilObservable');
  Result := Self;
end;

class function TExtUtilJSONSingleton.JSClassName: string;
begin
  Result := 'Ext.util.JSON';
end;

function TExtUtilJSONSingleton.Decode(Json: string): TExtFunction;
begin
  JSCode(JSName + '.decode(' + VarToJSON([Json]) + ');', 'TExtUtilJSONSingleton');
  Result := Self;
end;

function TExtUtilJSONSingleton.Encode(O: string): TExtFunction;
begin
  JSCode(JSName + '.encode(' + VarToJSON([O]) + ');', 'TExtUtilJSONSingleton');
  Result := Self;
end;

function TExtUtilJSONSingleton.EncodeDate(D: TDateTime): TExtFunction;
begin
  JSCode(JSName + '.encodeDate(' + VarToJSON([D]) + ');', 'TExtUtilJSONSingleton');
  Result := Self;
end;

class function TExtUtilTextMetricsSingleton.JSClassName: string;
begin
  Result := 'Ext.util.TextMetrics';
end;

function TExtUtilTextMetricsSingleton.Bind(El: string): TExtFunction;
begin
  JSCode(JSName + '.bind(' + VarToJSON([El]) + ');', 'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.Bind(El: THTMLElement): TExtFunction;
begin
  JSCode(JSName + '.bind(' + VarToJSON([El, false]) + ');',
    'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.CreateInstance(El: string; FixedWidth: Integer = 0)
  : TExtFunction;
begin
  JSCode(JSName + '.createInstance(' + VarToJSON([El, FixedWidth]) + ');',
    'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.CreateInstance(El: THTMLElement;
  FixedWidth: Integer = 0): TExtFunction;
begin
  JSCode(JSName + '.createInstance(' + VarToJSON([El, false, FixedWidth]) + ');',
    'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.GetHeight(const AText: string): TExtFunction;
begin
  ExtSession.ResponseItems.CallMethod(Self, 'getHeight', [AText]);
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.GetSize(Text: string): TExtFunction;
begin
  JSCode(JSName + '.getSize(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.GetWidth(const AText: string): TExtFunction;
begin
  ExtSession.ResponseItems.CallMethod(Self, 'getWidth', [AText]);
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.Measure(El: string; Text: string;
  FixedWidth: Integer = 0): TExtFunction;
begin
  JSCode(JSName + '.measure(' + VarToJSON([El, Text, FixedWidth]) + ');',
    'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.Measure(El: THTMLElement; Text: string;
  FixedWidth: Integer = 0): TExtFunction;
begin
  JSCode(JSName + '.measure(' + VarToJSON([El, false, Text, FixedWidth]) + ');',
    'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

function TExtUtilTextMetricsSingleton.SetFixedWidth(Width: Integer): TExtFunction;
begin
  JSCode(JSName + '.setFixedWidth(' + VarToJSON([Width]) + ');',
    'TExtUtilTextMetricsSingleton');
  Result := Self;
end;

class function TExtUtilFormatSingleton.JSClassName: string;
begin
  Result := 'Ext.util.Format';
end;

function TExtUtilFormatSingleton.Capitalize(Value: string): TExtFunction;
begin
  JSCode(JSName + '.capitalize(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Date(Value: string; Format: string = ''): TExtFunction;
begin
  JSCode(JSName + '.date(' + VarToJSON([Value, Format]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Date(Value: TDateTime; Format: string = '')
  : TExtFunction;
begin
  JSCode(JSName + '.date(' + VarToJSON([Value, Format]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.DateRenderer(Format: string): TExtFunction;
begin
  JSCode(JSName + '.dateRenderer(' + VarToJSON([Format]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.DefaultValue(Value: string; DefaultValue: string)
  : TExtFunction;
begin
  JSCode(JSName + '.defaultValue(' + VarToJSON([Value, DefaultValue]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Ellipsis(Value: string; Length: Integer; Word: Boolean)
  : TExtFunction;
begin
  JSCode(JSName + '.ellipsis(' + VarToJSON([Value, Length, Word]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.FileSize(Size: Integer): TExtFunction;
begin
  JSCode(JSName + '.fileSize(' + VarToJSON([Size]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.FileSize(Size: string): TExtFunction;
begin
  JSCode(JSName + '.fileSize(' + VarToJSON([Size]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.HtmlDecode(Value: string): TExtFunction;
begin
  JSCode(JSName + '.htmlDecode(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.HtmlEncode(Value: string): TExtFunction;
begin
  JSCode(JSName + '.htmlEncode(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Lowercase(Value: string): TExtFunction;
begin
  JSCode(JSName + '.lowercase(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Math: TExtFunction;
begin
  JSCode(JSName + '.math();', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Nl2br(The: string): TExtFunction;
begin
  JSCode(JSName + '.nl2br(' + VarToJSON([The]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Number(V: Integer; Format: string): TExtFunction;
begin
  JSCode(JSName + '.number(' + VarToJSON([V, Format]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.NumberRenderer(Format: string): TExtFunction;
begin
  JSCode(JSName + '.numberRenderer(' + VarToJSON([Format]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Plural(Value: Integer; Singular: string;
  Plural: string = ''): TExtFunction;
begin
  JSCode(JSName + '.plural(' + VarToJSON([Value, Singular, Plural]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Round(Value: Integer; Precision: Integer): TExtFunction;
begin
  JSCode(JSName + '.round(' + VarToJSON([Value, Precision]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Round(Value: string; Precision: Integer): TExtFunction;
begin
  JSCode(JSName + '.round(' + VarToJSON([Value, Precision]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.StripScripts(Value: string): TExtFunction;
begin
  JSCode(JSName + '.stripScripts(' + VarToJSON([Value]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.StripTags(Value: string): TExtFunction;
begin
  JSCode(JSName + '.stripTags(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Substr(Value: string; Start: Integer; Length: Integer)
  : TExtFunction;
begin
  JSCode(JSName + '.substr(' + VarToJSON([Value, Start, Length]) + ');',
    'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Trim(Value: string): TExtFunction;
begin
  JSCode(JSName + '.trim(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Undef(Value: string): TExtFunction;
begin
  JSCode(JSName + '.undef(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.Uppercase(Value: string): TExtFunction;
begin
  JSCode(JSName + '.uppercase(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.UsMoney(Value: Integer): TExtFunction;
begin
  JSCode(JSName + '.usMoney(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

function TExtUtilFormatSingleton.UsMoney(Value: string): TExtFunction;
begin
  JSCode(JSName + '.usMoney(' + VarToJSON([Value]) + ');', 'TExtUtilFormatSingleton');
  Result := Self;
end;

class function TExtUtilCSSSingleton.JSClassName: string;
begin
  Result := 'Ext.util.CSS';
end;

function TExtUtilCSSSingleton.CreateStyleSheet(CssText: string; Id: string): TExtFunction;
begin
  JSCode(JSName + '.createStyleSheet(' + VarToJSON([CssText, Id]) + ');',
    'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRule(Selector: string; RefreshCache: Boolean)
  : TExtFunction;
begin
  JSCode(JSName + '.getRule(' + VarToJSON([Selector, RefreshCache]) + ');',
    'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRule(Selector: TExtObjectList; RefreshCache: Boolean)
  : TExtFunction;
begin
  JSCode(JSName + '.getRule(' + VarToJSON(Selector) + ',' + VarToJSON([RefreshCache]) +
    ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRules(RefreshCache: Boolean): TExtFunction;
begin
  JSCode(JSName + '.getRules(' + VarToJSON([RefreshCache]) + ');',
    'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.RefreshCache: TExtFunction;
begin
  JSCode(JSName + '.refreshCache();', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.RemoveStyleSheet(Id: string): TExtFunction;
begin
  JSCode(JSName + '.removeStyleSheet(' + VarToJSON([Id]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.SwapStyleSheet(Id: string; Url: string): TExtFunction;
begin
  JSCode(JSName + '.swapStyleSheet(' + VarToJSON([Id, Url]) + ');',
    'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.UpdateRule(Selector: string; PropertyJS: string;
  Value: string): TExtFunction;
begin
  JSCode(JSName + '.updateRule(' + VarToJSON([Selector, PropertyJS, Value]) + ');',
    'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.UpdateRule(Selector: TExtObjectList; PropertyJS: string;
  Value: string): TExtFunction;
begin
  JSCode(JSName + '.updateRule(' + VarToJSON(Selector) + ',' +
    VarToJSON([PropertyJS, Value]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

class function TExtUtilCookiesSingleton.JSClassName: string;
begin
  Result := 'Ext.util.Cookies';
end;

function TExtUtilCookiesSingleton.Clear(Name: string): TExtFunction;
begin
  JSCode(JSName + '.clear(' + VarToJSON([name]) + ');', 'TExtUtilCookiesSingleton');
  Result := Self;
end;

function TExtUtilCookiesSingleton.Get(Name: string): TExtFunction;
begin
  JSCode(JSName + '.get(' + VarToJSON([name]) + ');', 'TExtUtilCookiesSingleton');
  Result := Self;
end;

function TExtUtilCookiesSingleton.SetJS(Name: string; Value: string;
  Expires: TExtObject = nil; Path: string = ''; Domain: string = '';
  Secure: Boolean = false): TExtFunction;
begin
  JSCode(JSName + '.set(' + VarToJSON([name, Value, Expires, false, Path, Domain, Secure])
    + ');', 'TExtUtilCookiesSingleton');
  Result := Self;
end;

class function TExtUtilDelayedTask.JSClassName: string;
begin
  Result := 'Ext.util.DelayedTask';
end;

constructor TExtUtilDelayedTask.Create(AOwner: TComponent; Fn: TExtFunction = nil;
  Scope: TExtObject = nil; Args: TExtObjectList = nil);
begin
  FCreateVarArgs := JSClassName + '(' + VarToJSON([Fn, True, Scope, False], GetExtSession(AOwner)) + ',' +
    VarToJSON(Args) + ');';
  inherited Create(AOwner);
end;

function TExtUtilDelayedTask.Cancel: TExtFunction;
begin
  JSCode(JSName + '.cancel();', 'TExtUtilDelayedTask');
  Result := Self;
end;

function TExtUtilDelayedTask.Delay(Delay: Integer; NewFn: TExtFunction = nil;
  NewScope: TExtObject = nil; NewArgs: TExtObjectList = nil): TExtFunction;
begin
  JSCode(JSName + '.delay(' + VarToJSON([Delay, NewFn, true, NewScope, false]) + ',' +
    VarToJSON(NewArgs) + ');', 'TExtUtilDelayedTask');
  Result := Self;
end;

procedure TExtUtilMixedCollection.SetFAllowFunctions(Value: Boolean);
begin
  FAllowFunctions := Value;
  JSCode('allowFunctions:' + VarToJSON([Value]));
end;

procedure TExtUtilMixedCollection.SetFOnAdd(Value: TExtUtilMixedCollectionOnAdd);
begin
  if Assigned(FOnAdd) then
    JSCode(JSName + '.events ["add"].listeners=[];');
  if Assigned(Value) then
    on('add', Ajax('add', ['Index', '%0', 'O', '%1.nm', 'Key', '%2'], true));
  FOnAdd := Value;
end;

procedure TExtUtilMixedCollection.SetFOnClear(Value: TExtUtilMixedCollectionOnClear);
begin
  if Assigned(FOnClear) then
    JSCode(JSName + '.events ["clear"].listeners=[];');
  if Assigned(Value) then
    on('clear', Ajax('clear', [], true));
  FOnClear := Value;
end;

procedure TExtUtilMixedCollection.SetFOnRemove(Value: TExtUtilMixedCollectionOnRemove);
begin
  if Assigned(FOnRemove) then
    JSCode(JSName + '.events ["remove"].listeners=[];');
  if Assigned(Value) then
    on('remove', Ajax('remove', ['O', '%0.nm', 'Key', '%1'], true));
  FOnRemove := Value;
end;

procedure TExtUtilMixedCollection.SetFOnReplace(Value: TExtUtilMixedCollectionOnReplace);
begin
  if Assigned(FOnReplace) then
    JSCode(JSName + '.events ["replace"].listeners=[];');
  if Assigned(Value) then
    on('replace', Ajax('replace', ['Key', '%0', 'Old', '%1.nm', 'New', '%2.nm'], true));
  FOnReplace := Value;
end;

class function TExtUtilMixedCollection.JSClassName: string;
begin
  Result := 'Ext.util.MixedCollection';
end;

constructor TExtUtilMixedCollection.Create(AOwner: TComponent; AllowFunctions: Boolean;
  KeyFn: TExtFunction);
begin
  FCreateVarArgs := JSClassName + '(' + VarToJSON([AllowFunctions, KeyFn, True], GetExtSession(AOwner)) + ');';
  inherited Create(AOwner);
end;

function TExtUtilMixedCollection.Add(Key: string; O: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.add(' + VarToJSON([Key, O, false]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.AddAll(Objs: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.addAll(' + VarToJSON([Objs, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.AddAll(Objs: TExtObjectList): TExtFunction;
begin
  JSCode(JSName + '.addAll(' + VarToJSON(Objs) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Clear: TExtFunction;
begin
  JSCode(JSName + '.clear();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Clone: TExtFunction;
begin
  JSCode(JSName + '.clone();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Contains(O: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.contains(' + VarToJSON([O, false]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.ContainsKey(Key: string): TExtFunction;
begin
  JSCode(JSName + '.containsKey(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Each(Fn: TExtFunction; Scope: TExtObject = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.EachKey(Fn: TExtFunction; Scope: TExtObject = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.eachKey(' + VarToJSON([Fn, true, Scope, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Filter(PropertyJS: string; Value: string;
  AnyMatch: Boolean = false; CaseSensitive: Boolean = false): TExtFunction;
begin
  JSCode(JSName + '.filter(' + VarToJSON([PropertyJS, Value, AnyMatch, CaseSensitive]) +
    ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Filter(PropertyJS: string; Value: TRegExp;
  AnyMatch: Boolean = false; CaseSensitive: Boolean = false): TExtFunction;
begin
  JSCode(JSName + '.filter(' + VarToJSON([PropertyJS, #3 + Value, AnyMatch, CaseSensitive]
    ) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.FilterBy(Fn: TExtFunction; Scope: TExtObject = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.filterBy(' + VarToJSON([Fn, true, Scope, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Find(Fn: TExtFunction; Scope: TExtObject = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.find(' + VarToJSON([Fn, true, Scope, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.FindIndex(PropertyJS: string; Value: string;
  Start: Integer = 0; AnyMatch: Boolean = false; CaseSensitive: Boolean = false)
  : TExtFunction;
begin
  JSCode(JSName + '.findIndex(' + VarToJSON([PropertyJS, Value, Start, AnyMatch,
    CaseSensitive]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.FindIndex(PropertyJS: string; Value: TRegExp;
  Start: Integer = 0; AnyMatch: Boolean = false; CaseSensitive: Boolean = false)
  : TExtFunction;
begin
  JSCode(JSName + '.findIndex(' + VarToJSON([PropertyJS, #3 + Value, Start, AnyMatch,
    CaseSensitive]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.FindIndexBy(Fn: TExtFunction; Scope: TExtObject = nil;
  Start: Integer = 0): TExtFunction;
begin
  JSCode(JSName + '.findIndexBy(' + VarToJSON([Fn, true, Scope, false, Start]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.First: TExtFunction;
begin
  JSCode(JSName + '.first();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Get(Key: string): TExtFunction;
begin
  JSCode(JSName + '.get(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Get(Key: Integer): TExtFunction;
begin
  JSCode(JSName + '.get(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.GetCount: TExtFunction;
begin
  JSCode(JSName + '.getCount();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.GetKey(Item: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.getKey(' + VarToJSON([Item, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.GetRange(StartIndex: Integer = 0; EndIndex: Integer = 0)
  : TExtFunction;
begin
  JSCode(JSName + '.getRange(' + VarToJSON([StartIndex, EndIndex]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.IndexOf(O: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.indexOf(' + VarToJSON([O, false]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.IndexOfKey(Key: string): TExtFunction;
begin
  JSCode(JSName + '.indexOfKey(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Insert(Index: Integer; Key: string; O: TExtObject = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.insert(' + VarToJSON([index, Key, O, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Item(Key: string): TExtFunction;
begin
  JSCode(JSName + '.item(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Item(Key: Integer): TExtFunction;
begin
  JSCode(JSName + '.item(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.ItemAt(Index: Integer): TExtFunction;
begin
  JSCode(JSName + '.itemAt(' + VarToJSON([index]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Key(Key: string): TExtFunction;
begin
  JSCode(JSName + '.key(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Key(Key: Integer): TExtFunction;
begin
  JSCode(JSName + '.key(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.KeySort(Direction: string = ''; Fn: TExtFunction = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.keySort(' + VarToJSON([Direction, Fn, true]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Last: TExtFunction;
begin
  JSCode(JSName + '.last();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Remove(O: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.remove(' + VarToJSON([O, false]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.RemoveAt(Index: Integer): TExtFunction;
begin
  JSCode(JSName + '.removeAt(' + VarToJSON([index]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.RemoveKey(Key: string): TExtFunction;
begin
  JSCode(JSName + '.removeKey(' + VarToJSON([Key]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Reorder(Mapping: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.reorder(' + VarToJSON([Mapping, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Replace(Key: string; O: TExtObject): TExtFunction;
begin
  JSCode(JSName + '.replace(' + VarToJSON([Key, O, false]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Sort(Direction: string = ''; Fn: TExtFunction = nil)
  : TExtFunction;
begin
  JSCode(JSName + '.sort(' + VarToJSON([Direction, Fn, true]) + ');',
    'TExtUtilMixedCollection');
  Result := Self;
end;

procedure TExtUtilMixedCollection.HandleEvent(const AEvtName: string);
begin
  inherited;
  if (AEvtName = 'add') and Assigned(FOnAdd) then
    FOnAdd(ParamAsInteger('Index'), TExtObject(ParamAsObject('O')), ParamAsString('Key'))
  else if (AEvtName = 'clear') and Assigned(FOnClear) then
    FOnClear()
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtObject(ParamAsObject('O')), ParamAsString('Key'))
  else if (AEvtName = 'replace') and Assigned(FOnReplace) then
    FOnReplace(ParamAsString('Key'), TExtObject(ParamAsObject('Old')),
      TExtObject(ParamAsObject('New')));
end;

end.

